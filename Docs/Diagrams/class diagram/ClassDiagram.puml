@startuml
'skinparam classAttributeIconSize 0
'scale 1.5
'left to right direction
skinparam linetype ortho


package BL {

	package JADE <<External library>> {

		abstract class Agent <<Abstract, JADE>> {
		    {abstract} #Setup() : void
		    addBehaviour(Behaviour b) : void
		}

		abstract class Behaviour <<Abstract, JADE>>
		Behaviour -- Agent

		class DFAgentDescription
	}

	package DataObjects{
		
		together {
			class Device {
				+name : String
				+subtype : String
				+location : String
			}

			class Sensor {
				+currState : double
				+sensingProperties : List<String>
				+change(double) : void
			}

			class Actuator {
				+act(Map<Sensor, double>, Action) : void
			}
		}

		together {
			class Effect {
				+property : String
				+delta : double
			}

			class Action {
				+name : String
				+powerConsumption : double
			}
		}

		together {
			enum RelationType {
			EQ
			GEQ
			LEQ
			GT
			LT
			}

			enum Prefix {
				BEFORE
				AFTER
				AT
			}

			class Rule {
				+isActive : boolean
				+property : String
				+ruleValue : double
				+relationValue : double
			}
		}

		'agentdata and problem'
		together {
			class AgentData {
				+name : String
				+backgroundLoad : double[Problem.horizon]
				+priceSchema : double[Problem.horizon]
				+houseType : int
				+numOfIterations : int
				+priceScheme : double[]
				+granularity : int
			}

			class Problem {
				id : String
				allDevices : Map<Integer, List<Device>>
				horizon : int
				granularity : int
				priceScheme : double[horizon]
			}
		}

		Device <|- Sensor
		Device <|-- Actuator

		Actuator o-- Action
		Action o-- Effect

		Problem *-- AgentData
		AgentData o-- Sensor
		AgentData o-- Actuator
		AgentData -- AgentData
		AgentData o- Rule

		Prefix <-- Rule
		RelationType <-- Rule
		Rule o-- Device
	}

	package Agents {

		'helpers'
		together {
			class AlgorithmDataHelper {
				+totalPriceConsumption : double
				+DeviceToTicks : Map<Actuator, Map<Action, List<Integer>>>
				
				+allProperties : List<PropertyWithData>
				+buildNewPropertyData(Rule, boolean) : void
				+setActuatorsAndSensors() : void
				+getSubsets(List<Integer>, int) : List<Set<int>>
				+calcPriceSchemeForAllNeighbours() : void
				+calcTotalPowerConsumption(double, double[]) : double
				+calcAndSetTotalPowerConsumption(double) : void
				+calcTotalPowerConsumption(double) : double
				+checkForPassiveRules() : void
				+calcHowLongDeviceNeedToWork(PropertyWithData) : double
				+goBackToStartValues() : void
				+coneArray(double[]) : double[]
				+coneList(List) : List
			}

			class PropertyWithData {
				+name : String
				+min : double
				+max : double
				+targetValue : double
				+targetTick : double
				+deltaWhenWork : double
				+isPasiveOnly : boolean
				+powerConsumedInWork : double
				+deltaWhenWorkOffline : double
				+isLocation : boolean
				+relatedSensorsDelta : Map<String,Double>
				+relatedSensorsWhenWorkOfflineDelta : Map<String,Double>
				+calcAndUpdateCurrState(double, double, double[], boolean) : void
				+updateValueToSensor(double[], double, double, int, boolean) : double
			}
		}

		'agent'
		together {
			class SmartHomeAgent {
				+{static} SERVICE_TYPE : String
				+{static} SERVICE_NAME : String
				+numOfIterations : int
				+iterationNum : int
				+isZEROIteration : boolean
				+cSum : double
				+problemId : String
				+algoId : String

				#setup() : void
				#takeDown() : void
				addBehaviour(Behaviour) : void
			}


			abstract class SmartHomeAgentBehaviour <<Abstract>> {
				+agent : SmartHomeAgent
				#currentNumberOfIter: int
				#helper: AlgorithmDataHelper
				#agentIterationData: AgentIterationData
				#agentIterationCollected: IterationCollectedData
				#iterationPowerConsumption: double[]
				#tempPriceConsumption: double

				#{abstract} doIteration() : void
				#{abstract} onTermination() : void
				#{abstract} countIterationCommunication() : void
				#{abstract} generateScheduleForProp(PropertyWithData, double, Map<String, Integer>, boolean) : void
				#{abstract} cloneBehaviour() : SmartHomeAgentBehaviour
				#{abstract} calcImprveOptionGrade(double[], List<double[]>) : double
				#sendIterationToCollector() : void
				#sendIterationToNeighbors() : void
				#sendMsgToAllNeighbors(Serializable, String) : void
				#waitForNeighbourMessages(MessageTemplate) : List<ACLMessage>
				#readNeighbourMsgs(List<ACLMessage>) : void
				#parseMessages(List<ACLMessage>) : void
				#initHelper() : void
				#calcPrice(double[]) : double
				#calcCsum(double[]) : double
				#initializeBehaviourWithAgent(SmartHomeAgent) : void
				#addBackgroundLoadToPriceScheme(double[]) : void
				#buildScheduleBasic(boolean) : void
				#calcHowManyTicksNeedToCharge(String, double, double) : int
				#drawRandomNum(int, int) : int
				#flipCoin(float) : boolean
				#updateTotals(PropertyWithData, Map<String, Integer>, double): void
				#startWorkZERO(PropertyWithData, Map<String, Integer>, double): void
				#startWorkNonZeroIter(PropertyWithData, Map<String, Integer>, double): void
				#calcRangeOfWork(PropertyWithData): List<int>
				#calcBestPrice(PropertyWithData, List<Set<Integer>>): List<int>
				#beforeIterationIsDone(): void
				+cloneBehaviour() : SmartHomeAgentBehaviour
				+buildScheduleFromScratch() : void

				+action() : void
				+done() : boolean
			}
		}

		Note "action(){\n\tdoIteration();\n\tsendIterationToCollector();\n\tsendIterationToNeighbrs();\n\t..\n\t}\n}" as smabNote
		
		'algos:'
		together {
			class SHMGM {
				+doIteration() : void
				-onTermination() : void
				-countIterationCommunication() : void
				-generateScheduleForProp(PropertyWithData, double, Map<String, Integer>, boolean) : void
				-cloneBehaviour() : SmartHomeAgentBehaviour
				-calcImprveOptionGrade(double[], List<double[]>) : double
			}

			class DSA {
				+doIteration() : void
				-onTermination() : void
				-countIterationCommunication() : void
				-generateScheduleForProp(PropertyWithData, double, Map<String, Integer>, boolean) : void
				-cloneBehaviour() : SmartHomeAgentBehaviour
				-calcImprveOptionGrade(double[], List<double[]>) : double
			}

			class Algo3 {
				+doIteration : void
				-onTermination() : void
				-countIterationCommunication() : void
				-generateScheduleForProp(PropertyWithData, double, Map<String, Integer>, boolean) : void
				-cloneBehaviour() : SmartHomeAgentBehaviour
				-calcImprveOptionGrade(double[], List<double[]>) : double
			}

			class Algo4 {
				+doIteration() : void
				-onTermination() : void
				-countIterationCommunication() : void
				-generateScheduleForProp(PropertyWithData, double, Map<String, Integer>, boolean) : void
				-cloneBehaviour() : SmartHomeAgentBehaviour
				-calcImprveOptionGrade(double[], List<double[]>) : double
			}
		}


		Agent <|-- SmartHomeAgent
		SmartHomeAgentBehaviour --|> Behaviour
		SmartHomeAgent -- SmartHomeAgentBehaviour

		SmartHomeAgentBehaviour . smabNote

		Problem *-- Device

		SmartHomeAgentBehaviour <|-- SHMGM
		SmartHomeAgentBehaviour <|-- DSA
		SmartHomeAgentBehaviour <|-- Algo3
		SmartHomeAgentBehaviour <|-- Algo4

		DSA --> AlgorithmDataHelper
		DSA --> PropertyWithData

		AlgorithmDataHelper --> PropertyWithData
		AlgorithmDataHelper --> SmartHomeAgent
	}

	package IterationData {

		class AgentIterationData {
			+iterNum : int
			+agentName : String
			+price : double
			+powerConsumptionPerTick : double[]
		}

		class IterationCollectedData {
			+problemId : String
			+algorithm : String
			+neighborhood : Set<String>
			+epeak : double
			+messageSize: long
			+msgCount: int
		} 

		AgentIterationData <|-- IterationCollectedData
	}

	package DataCollection {

		class PowerConsumptionUtils <<Static>> {
			+{static} AE : double
			+{static} AC : double
			+{static} calculateCSum(List<double[]>, double[]) : double
			+{static} calculateTotalConsumptionWithPenalty(double, double[], double[], List<double[]>, double[]) : double
			+{static} calculateTotalConsumptionWithPenalty(double, List<double[]>) : double
		}

		'collecotrs'
		together {
			class DataCollector {
			    +numOfAgentsInProblems : Map<String, int>
			    +probAlgoToItAgentPrice : Map<ProblemAlgorithm, IterationAgentsPrice>
			    +probAlgoToResult : Map<ProblemAlgorithm, AlgorithmProblemResult>
			    +probToPriceScheme : Map<String, double[]>

			    +addData(IterationCollectedData) : void    
			}

			class DataCollectionCommunicator {
				+{static, final} SERVICE_TYPE : String
				+{static, final} SERVICE_NAME : String

				#setup() : void
				#takeDown() : void
			}

			class DataCollectionCommunicatorBehaviour {
			    +agent : DataCollectorCommunicator
				+action() : void
				+findAgents(String) : DFAgentDescription[]
			}
		}

		class StatisticsHandler {
			+getTotalPowerConsumption(): Map<String, List<Double>>
			+totalConsumption() : DefaultStatisticalCategoryDataset
			+lowestAgent() : DefaultStatisticalCategoryDataset
			+highestAgent() : DefaultStatisticalCategoryDataset
			+averageTime() : DefaultStatisticalCategoryDataset
			+messageSendPerIteration() : DefaultStatisticalCategoryDataset
			+messagesSize() : DefaultStatisticalCategoryDataset
			+{static} highestAgent(double[]) : double
		}

		class AlgorithmProblemResult {
			+problem : String
			+algorithm : String
			+avgPricePerIteration : Map<int, double>
			+iterationsTillBestPrice : int
			+bestGrade : double
			+lowestCostForAgentInBestIteration : double
			+lowestCostForAgentInBestIterationAgentName : String
			+highestCostForAgentInBestIteration : double
			+highestCostInForAgentBestIterationAgentName : String
		}

		DataCollector --o DataCollectionCommunicator
		DataCollector o-- IterationCollectedData
		DataCollectionCommunicatorBehaviour --|> Behaviour
		DataCollectionCommunicatorBehaviour --o DataCollectionCommunicator
		DataCollector --> StatisticsHandler
		
		DataCollector -> PowerConsumptionUtils
	}

	interface ExperimentBuilderInterface {
		+setNumOfIterations(int) : void
		+setAlgorithms(List<SmartHomeAgentBehaviour>) : void
		+setProblems(List<Problem>) : void
		+createExperiment() : Experiment
	}

	'experiment'
	together {
		class ExperimentBuilder {
			+setNumOfIterations(int) : void
			+setAlgorithms(List<SmartHomeAgentBehaviour>) : void
			+setProblems(List<Problem>) : void
			+createExperiment() : Experiment
		}

		interface ExperimentInterface {
			+runExperiment() : void
			+algorithmProblemComboRunEnded(AlgorithmProblemResult) : void
		}

		class Experiment {
			+{static} maximumIterations : int
			+numOfIterations : int
			+runExperiment() : void
			+algorithmProblemComboRunEnded(AlgorithmProblemResult) : void
		}

	}

	ExperimentInterface <|-- Experiment
	ExperimentBuilderInterface <|-- ExperimentBuilder

	ExperimentBuilder --> Experiment : creates
	Experiment o-- DataCollectionCommunicator
	Experiment *-- Problem
	SmartHomeAgent *- AgentData
	DataCollector --> AlgorithmProblemResult : creates
	DataCollectionCommunicator --> Experiment

	Experiment o-- AlgorithmProblemResult

	DataCollectionCommunicator "1" -- "1...*" SmartHomeAgentBehaviour
	DataCollectionCommunicator --> AgentIterationData
	DataCollector --> AgentIterationData
	DataCollectionCommunicatorBehaviour --> DFAgentDescription

	SmartHomeAgentBehaviour -> PowerConsumptionUtils
	SmartHomeAgent o- AgentIterationData

	PropertyWithData -> Actuator
	PropertyWithData --> Sensor
	PropertyWithData --> Prefix
	PropertyWithData --> RelationType
	AlgorithmDataHelper -> Actuator
	AlgorithmDataHelper --> Sensor
}

package PL {

	interface UiHandlerInterface {
		+notifyExperimentEnded(List<AlgorithmProblemResult>) : void
		+notifyError(String) : void
	}

	class UiHandler <<Observer>> {
		+notifyExperimentEnded(List<AlgorithmProblemResult>) : void
		+notifyError(String) : void
	}
	UiHandlerInterface <|-- UiHandler
}

package DAL {

    interface FileSaverInterface {
    	+saveExpirimentResult(List<AlgorithmProblemResult>) : void
    }

	class CsvHandler {
    	+saveExpirimentResult(List<AlgorithmProblemResult>) : void
	}

    interface JsonLoaderInterface {
        +loadDevices(String) : Map<int, List<Device>>
        +loadProblems(List<String>) : List<Problem>
        +getAllProblemNames() : Map<Integer, List<String>>
    }

	class JsonsLoader {
		+loadDevices(String) : Map<int, List<Device>>
        +loadProblems(List<String>) : List<Problem>
        +getAllProblemNames() : Map<Integer, List<String>>
	}

    interface AlgoLoaderInterface {
		+loadAlgorithms(List<String>) : SmartHomeAgentBehaviour
        +getAllAlgoNames() : List<String>
        +addAlgoToSystem(String, String) : void
    }

	class AlgorithmLoader {
		+loadAlgorithms(List<String>) : SmartHomeAgentBehaviour
        +getAllAlgoNames() : List<String>
        +addAlgoToSystem(String, String) : void
	}

    interface DataAccessControllerInterface {
        +getProblems(List<String>) : List<Problem>
        +getAvailableAlgorithms() : List<String>
        +getAvailableProblems() : Map<Integer, List<String>>
        +getAlgorithms(List<String>) : List<SmartHomeAgentBehaviour>
        +addAlgorithmToSystem(String, String) : void
        +saveExpirimentResult(List<AlgorithmProblemResult>) : void
    }

	class DataAccessController {
		+getProblems(List<String>) : List<Problem>
		+getAvailableAlgorithms() : List<String>
        +getAvailableProblems() : Map<Integer, List<String>>
		+getAlgorithms(List<String>) : List<SmartHomeAgentBehaviour>
		+addAlgorithmToSystem(String, String) : void
		+saveExpirimentResult(List<AlgorithmProblemResult>) : void
	}

	DataAccessController --> AlgoLoaderInterface
	DataAccessController --> JsonLoaderInterface
	DataAccessController --> FileSaverInterface

	JsonLoaderInterface <|-- JsonsLoader
	AlgoLoaderInterface <|-- AlgorithmLoader
	DataAccessControllerInterface <|-- DataAccessController
	FileSaverInterface <|-- CsvHandler
}

together {
	interface ServiceInterface {
		+addAlgorithmsToExperiment(List<String>, int) : void
		+addProblemsToExperiment(List<String>) : void
		+runExperimrent() : void
		' +stopExperiment() : void
		+getExperimentResults() : List<AlgorithmProblemResult>
	    +experimentEnded(List<AlgorithmProblemResult>) : void
	    +saveExperimentResults(List<AlgorithmProblemResult>) : void
	}

	class Service <<Observable>> {
		+setObserver(UiHandler) : void
		+addAlgorithmsToExperiment(List<SmartHomeAgentBehaviour>, int) : void
		+addProblemsToExperiment(List<Problem>) : void
		+runExperimrent() : void
		' +stopExperiment() : void
		+getExperimentResults() : List<AlgorithmProblemResult>
	    +experimentEnded(List<AlgorithmProblemResult>) : void
	    +experimentEndedWithError(Exception) : void
	    +saveExperimentResults(List<AlgorithmProblemResult>) : void
	}
}

ServiceInterface <|-- Service

class SmartHomeAlgorithm <<Not Implemented>> {
	-doIteration() : void
}

'**********out of package connections:************
Service --> ExperimentInterface
Experiment --> Service
Service --> AlgorithmProblemResult
Service --> ExperimentBuilderInterface

JsonsLoader --> Device : creates >
JsonsLoader -> Problem : creates >
AlgorithmLoader --> SmartHomeAgentBehaviour : creates >
DataAccessController --> Problem
DataCollectionCommunicator --|> Agent

ExperimentBuilder --> DataAccessControllerInterface

CsvHandler -> AlgorithmProblemResult : saves

SmartHomeAlgorithm --|> SmartHomeAgentBehaviour

UiHandler --> ServiceInterface
UiHandlerInterface <-- Service


@enduml